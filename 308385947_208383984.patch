diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..abae318
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,2 @@
+.vscode
+.idea/
\ No newline at end of file
diff --git a/Makefile b/Makefile
index 328f9c6..8b19de6 100644
--- a/Makefile
+++ b/Makefile
@@ -87,7 +87,7 @@ $U/initcode: $U/initcode.S
 tags: $(OBJS) _init
 	etags *.S *.c
 
-ULIB = $U/ulib.o $U/usys.o $U/printf.o $U/umalloc.o
+ULIB = $U/ulib.o $U/usys.o $U/printf.o $U/umalloc.o $U/Csemaphore.o
 
 _%: %.o $(ULIB)
 	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
@@ -132,7 +132,10 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
-
+	$U/_test\
+	$U/_print_ptable\
+	$U/_sem_test\
+	
 fs.img: mkfs/mkfs README $(UPROGS)
 	mkfs/mkfs fs.img README $(UPROGS)
 
diff --git a/a.patch b/a.patch
new file mode 100644
index 0000000..f9dde0e
--- /dev/null
+++ b/a.patch
@@ -0,0 +1,859 @@
+diff --git a/kernel/defs.h b/kernel/defs.h
+index 1e18377..8b7f1bd 100644
+--- a/kernel/defs.h
++++ b/kernel/defs.h
+@@ -8,8 +8,6 @@ struct spinlock;
+ struct sleeplock;
+ struct stat;
+ struct superblock;
+-struct sigaction;
+-struct trapframe;
+ 
+ // bio.c
+ void            binit(void);
+@@ -91,7 +89,7 @@ int             growproc(int);
+ void            proc_mapstacks(pagetable_t);
+ pagetable_t     proc_pagetable(struct proc *);
+ void            proc_freepagetable(pagetable_t, uint64);
+-int             kill(int, int);
++int             kill(int,int);
+ struct cpu*     mycpu(void);
+ struct cpu*     getmycpu(void);
+ struct proc*    myproc();
+@@ -110,7 +108,6 @@ void            procdump(void);
+ uint            sigprocmask(uint);
+ int             sigaction(int, uint64, uint64);
+ void            sigret(void);
+-
+ // swtch.S
+ void            swtch(struct context*, struct context*);
+ 
+@@ -151,13 +148,9 @@ void            trapinit(void);
+ void            trapinithart(void);
+ extern struct spinlock tickslock;
+ void            usertrapret(void);
+-void            kill_handler(struct proc*);
+-void            stop_handler(struct proc*);
+-void            handle_user_signal(struct proc*,int);
+ void            handle_signals(struct proc*);
+-void            add_sigret();
+-void            end_of_add_sigret();
+-void            copy_tf(struct trapframe*, struct trapframe*);
++void            kill_handler(struct proc *);
++void            stop_handler(struct proc*);
+ 
+ 
+ // uart.c
+diff --git a/kernel/exec.c b/kernel/exec.c
+index a086eeb..d9f5263 100644
+--- a/kernel/exec.c
++++ b/kernel/exec.c
+@@ -97,19 +97,21 @@ exec(char *path, char **argv)
+   if(copyout(pagetable, sp, (char *)ustack, (argc+1)*sizeof(uint64)) < 0)
+     goto bad;
+ 
+-  // arguments to user main(argc, argv)
+-  // argc is returned via the system call return
+-  // value, which goes in a0.
+-  p->trapframe->a1 = sp;
+-
+-  //our additions:
+-  for(int i = 0; i < 32; i++)
++  //---------------------our additions--------------
++  for (int i=0; i<NUM_OF_SIGNALS ; i++)
+   {
+-    if(( p->signal_handlers[i] != SIG_DFL) && ( p->signal_handlers[i] != (void*)SIG_IGN))
++    if ((p->signal_handlers[i] != SIG_DFL) && (p->signal_handlers[i] != (void*) SIG_IGN))
+     {
+       p->signal_handlers[i] = SIG_DFL;
++      p->signal_masks[i] = 0;
+     }
+   }
++  //------------------------------------------------
++
++  // arguments to user main(argc, argv)
++  // argc is returned via the system call return
++  // value, which goes in a0.
++  p->trapframe->a1 = sp;
+ 
+   // Save program name for debugging.
+   for(last=s=path; *s; s++)
+@@ -125,7 +127,6 @@ exec(char *path, char **argv)
+   p->trapframe->sp = sp; // initial stack pointer
+   proc_freepagetable(oldpagetable, oldsz);
+ 
+-
+   return argc; // this ends up in a0, the first argument to main(argc, argv)
+ 
+  bad:
+diff --git a/kernel/param.h b/kernel/param.h
+index d9f9ca8..4838889 100644
+--- a/kernel/param.h
++++ b/kernel/param.h
+@@ -11,10 +11,9 @@
+ #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
+ #define FSSIZE       1000  // size of file system in blocks
+ #define MAXPATH      128   // maximum file path name
+-
+-//our additions
+-#define SIG_DFL 0
+-#define SIG_IGN 1
+-#define SIGKILL 9
+-#define SIGSTOP 17
+-#define SIGCONT 19
++#define SIG_DFL       0
++#define SIG_IGN       1
++#define SIGKILL       9
++#define SIGSTOP       17
++#define SIGCONT       19
++#define NUM_OF_SIGNALS 32
+\ No newline at end of file
+diff --git a/kernel/proc.c b/kernel/proc.c
+index def05d8..d89be75 100644
+--- a/kernel/proc.c
++++ b/kernel/proc.c
+@@ -121,36 +121,37 @@ found:
+   p->pid = allocpid();
+   p->state = USED;
+ 
+-  //our additions:
+-  p->pending_signals = 0;
+-  for(int i = 0; i < 32; i++)
+-  {
+-    p->signal_handlers[i] = SIG_DFL;
+-    p->signal_masks[i] = 0;
+-  }
+-  p->proc_signal_mask = 0;
+-  p->freezed = 0;
+   // Allocate a trapframe page.
+-  if((p->trapframe_backup = (struct trapframe *)kalloc()) == 0){
++  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
+     freeproc(p);
+     release(&p->lock);
+     return 0;
+   }
+ 
+-  // Allocate a trapframe page.
+-  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
++  // An empty user page table.
++  p->pagetable = proc_pagetable(p);
++  if(p->pagetable == 0){
+     freeproc(p);
+     release(&p->lock);
+     return 0;
+   }
+ 
+-  // An empty user page table.
+-  p->pagetable = proc_pagetable(p);
+-  if(p->pagetable == 0){
++  //-----------------our additions----------------
++  p->pending_signals = 0;
++  p->proc_signal_mask = 0;
++  for (int i=0 ; i<NUM_OF_SIGNALS ; i++)
++  {
++    p->signal_handlers[i] = SIG_DFL;
++    p->signal_masks[i] = 0;
++  }
++  if((p->tf_backup = (struct trapframe *)kalloc()) == 0){
+     freeproc(p);
+     release(&p->lock);
+     return 0;
+   }
++  p->freezed = 0;
++
++  //----------------------------------------------
+ 
+   // Set up new context to start executing at forkret,
+   // which returns to user space.
+@@ -306,14 +307,15 @@ fork(void)
+   }
+   np->sz = p->sz;
+ 
+-  //our additions:
+-  np->proc_signal_mask = 0;
+-  np->pending_signals = p->pending_signals;
++  //-------------------our additions-----------------
++  np->pending_signals = 0;
+   np->proc_signal_mask = p->proc_signal_mask;
+-  for(int i = 0; i < 32; i++)
++  for (int i=0 ; i<NUM_OF_SIGNALS ; i++)
+   {
+     np->signal_handlers[i] = p->signal_handlers[i];
++    np->signal_masks[i] = p->signal_masks[i];
+   }
++  //-------------------------------------------------
+ 
+   // copy saved user registers.
+   *(np->trapframe) = *(p->trapframe);
+@@ -510,10 +512,13 @@ sched(void)
+   if(p->state == RUNNING)
+     panic("sched running");
+   if(intr_get())
+-    panic("sched interruptible");
++  panic("sched interruptible");
+ 
+   intena = mycpu()->intena;
++  printf("in sched before swtch\n");
+   swtch(&p->context, &mycpu()->context);
++  printf("in sched after swtch\n");
++
+   mycpu()->intena = intena;
+ }
+ 
+@@ -521,10 +526,13 @@ sched(void)
+ void
+ yield(void)
+ {
++  printf("in yeild\n");
+   struct proc *p = myproc();
+   acquire(&p->lock);
+   p->state = RUNNABLE;
+   sched();
++  printf("after sched\n");
++
+   release(&p->lock);
+ }
+ 
+@@ -605,15 +613,12 @@ int
+ kill(int pid, int signum)
+ {
+   struct proc *p;
++
+   for(p = proc; p < &proc[NPROC]; p++){
+     acquire(&p->lock);
+     if(p->pid == pid){
+-      uint new_mask = 1 << signum;
+-      p->pending_signals = p->pending_signals | new_mask;
+-      if(p->state == SLEEPING){
+-        // Wake process from sleep().
+-        p->state = RUNNABLE;
+-      }
++      printf("turned on %d for pid %d\n",(1<<signum) , p->pid);
++      p->pending_signals = p->pending_signals | (1<<signum) ; 
+       release(&p->lock);
+       return 0;
+     }
+@@ -681,45 +686,43 @@ procdump(void)
+   }
+ }
+ 
+-//our additions:
++
++//change the proc signal mask to @param:sigmask and return the old one
+ uint sigprocmask(uint sigmask)
+ {
+-  struct proc* p = myproc();
+-  uint old_mask = p->proc_signal_mask;
++  struct proc *p = myproc();
++  uint temp = p->proc_signal_mask;
+   p->proc_signal_mask = sigmask;
+-  return old_mask;
++  return temp;
+ }
+ 
+-int sigaction(int signum, uint64 act, uint64 old_act)
++//edit new signal handler when handeling the @param:signum signal 
++int sigaction(int signum , uint64 act, uint64 old_act)
+ {
+-  if((signum > 32) | (signum < 0) | (signum == SIGKILL)| (signum == SIGSTOP) )
++  struct proc *p = myproc();
++  struct sigaction kold_act;
++  struct sigaction kact;
++  if((signum < 0 ) || (signum >= NUM_OF_SIGNALS) || (signum == SIGKILL) || (signum == SIGSTOP))
+   {
+     return -1;
+   }
+-  struct proc* p = myproc();
+-  struct sigaction kernel_new_act;
+-  struct sigaction kernel_old_act;
+-  if (old_act != 0)
++  if(old_act != 0)
+   {
+-    kernel_old_act.sa_handler = p->signal_handlers[signum];
+-    kernel_old_act.sigmask = p->signal_masks[signum];
+-    copyout(p->pagetable, old_act, (char *)&kernel_old_act, sizeof(kernel_old_act));
++    kold_act.sa_handler = p->signal_handlers[signum];
++    kold_act.sigmask = p->signal_masks[signum];
++    copyout(p->pagetable, old_act, (char*) &kold_act, sizeof(struct sigaction));
+   }
+-  if (act != 0)
++  if(act != 0)
+   {
+-    copyin(p->pagetable,(char*) &kernel_new_act,act, sizeof(kernel_new_act));
+-    p->signal_handlers[signum] = kernel_new_act.sa_handler;
+-    p->signal_masks[signum] = kernel_new_act.sigmask;
++    copyin(p->pagetable, (char*) &kact, act, sizeof(struct sigaction));
++    p->signal_handlers[signum] = kact.sa_handler;
++    p->signal_masks[signum] = kact.sigmask;
+   }
+   return 0;
+ }
+ 
+ void sigret(void)
+ {
+-  //TODO in section 2.4
+-  printf("sigret!!!");
+-  struct proc *p = myproc();
+-  copy_tf(p->trapframe_backup,p->trapframe);
++  printf("in sigret\n");
+   return;
+-}
+-
++}
+\ No newline at end of file
+diff --git a/kernel/proc.h b/kernel/proc.h
+index eb3c356..e0bdfb3 100644
+--- a/kernel/proc.h
++++ b/kernel/proc.h
+@@ -106,12 +106,11 @@ struct proc {
+   struct inode *cwd;           // Current directory
+   char name[16];               // Process name (debugging)
+ 
+-  //our additions:
++  //---------------------our additions------------------
+   uint pending_signals;
+   uint proc_signal_mask;
+-  void* signal_handlers[32];
+-  uint signal_masks[32];
+-  struct trapframe *trapframe_backup;
++  void *signal_handlers[NUM_OF_SIGNALS];
++  uint signal_masks[NUM_OF_SIGNALS];
++  struct trapframe *tf_backup;
+   int freezed;
+-
+ };
+diff --git a/kernel/sigaction.h b/kernel/sigaction.h
+index 61a1cd0..fef16e5 100644
+--- a/kernel/sigaction.h
++++ b/kernel/sigaction.h
+@@ -1,4 +1,6 @@
++#include "kernel/types.h"
++
+ struct sigaction {
+-  void (*sa_handler) (int);
+-  uint sigmask;
+-};
++    void (*sa_handler) (int);
++    uint sigmask;
++};
+\ No newline at end of file
+diff --git a/kernel/string.c b/kernel/string.c
+index a896640..d99e612 100644
+--- a/kernel/string.c
++++ b/kernel/string.c
+@@ -1,11 +1,4 @@
+ #include "types.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "riscv.h"
+-#include "spinlock.h"
+-#include "proc.h"
+-#include "defs.h"
+-#include "sigaction.h"
+ 
+ void*
+ memset(void *dst, int c, uint n)
+diff --git a/kernel/syscall.c b/kernel/syscall.c
+index 3260135..20156b3 100644
+--- a/kernel/syscall.c
++++ b/kernel/syscall.c
+@@ -109,30 +109,30 @@ extern uint64 sys_sigaction(void);
+ extern uint64 sys_sigret(void);
+ 
+ static uint64 (*syscalls[])(void) = {
+-[SYS_fork]    sys_fork,
+-[SYS_exit]    sys_exit,
+-[SYS_wait]    sys_wait,
+-[SYS_pipe]    sys_pipe,
+-[SYS_read]    sys_read,
+-[SYS_kill]    sys_kill,
+-[SYS_exec]    sys_exec,
+-[SYS_fstat]   sys_fstat,
+-[SYS_chdir]   sys_chdir,
+-[SYS_dup]     sys_dup,
+-[SYS_getpid]  sys_getpid,
+-[SYS_sbrk]    sys_sbrk,
+-[SYS_sleep]   sys_sleep,
+-[SYS_uptime]  sys_uptime,
+-[SYS_open]    sys_open,
+-[SYS_write]   sys_write,
+-[SYS_mknod]   sys_mknod,
+-[SYS_unlink]  sys_unlink,
+-[SYS_link]    sys_link,
+-[SYS_mkdir]   sys_mkdir,
+-[SYS_close]   sys_close,
+-[SYS_sigprocmask] sys_sigprocmask,
+-[SYS_sigaction]   sys_sigaction,
+-[SYS_sigret]  sys_sigret,
++[SYS_fork]          sys_fork,
++[SYS_exit]          sys_exit,
++[SYS_wait]          sys_wait,
++[SYS_pipe]          sys_pipe,
++[SYS_read]          sys_read,
++[SYS_kill]          sys_kill,
++[SYS_exec]          sys_exec,
++[SYS_fstat]         sys_fstat,
++[SYS_chdir]         sys_chdir,
++[SYS_dup]           sys_dup,
++[SYS_getpid]        sys_getpid,
++[SYS_sbrk]          sys_sbrk,
++[SYS_sleep]         sys_sleep,
++[SYS_uptime]        sys_uptime,
++[SYS_open]          sys_open,
++[SYS_write]         sys_write,
++[SYS_mknod]         sys_mknod,
++[SYS_unlink]        sys_unlink,
++[SYS_link]          sys_link,
++[SYS_mkdir]         sys_mkdir,
++[SYS_close]         sys_close,
++[SYS_sigprocmask]   sys_sigprocmask,
++[SYS_sigaction]     sys_sigaction,
++[SYS_sigret]        sys_sigret,
+ };
+ 
+ void
+diff --git a/kernel/syscall.h b/kernel/syscall.h
+index ff42bcb..ea2a4d4 100644
+--- a/kernel/syscall.h
++++ b/kernel/syscall.h
+@@ -8,18 +8,18 @@
+ #define SYS_exec         7
+ #define SYS_fstat        8
+ #define SYS_chdir        9
+-#define SYS_dup         10
+-#define SYS_getpid      11
+-#define SYS_sbrk        12
+-#define SYS_sleep       13
+-#define SYS_uptime      14
+-#define SYS_open        15
+-#define SYS_write       16
+-#define SYS_mknod       17
+-#define SYS_unlink      18
+-#define SYS_link        19
+-#define SYS_mkdir       20
+-#define SYS_close       21
+-#define SYS_sigprocmask 22
+-#define SYS_sigaction   23
+-#define SYS_sigret      24
+\ No newline at end of file
++#define SYS_dup          10
++#define SYS_getpid       11
++#define SYS_sbrk         12
++#define SYS_sleep        13
++#define SYS_uptime       14
++#define SYS_open         15
++#define SYS_write        16
++#define SYS_mknod        17
++#define SYS_unlink       18
++#define SYS_link         19
++#define SYS_mkdir        20
++#define SYS_close        21
++#define SYS_sigprocmask  22
++#define SYS_sigaction    23
++#define SYS_sigret       24
+\ No newline at end of file
+diff --git a/kernel/sysproc.c b/kernel/sysproc.c
+index 3dff547..48ed211 100644
+--- a/kernel/sysproc.c
++++ b/kernel/sysproc.c
+@@ -76,10 +76,12 @@ sys_sleep(void)
+ uint64
+ sys_kill(void)
+ {
+-  int pid, signum;
++  int pid;
++  int signum; 
++
+   if((argint(0, &pid) < 0) || (argint(1, &signum) < 0))
+     return -1;
+-  return kill(pid, signum);
++  return kill(pid,signum);
+ }
+ 
+ // return how many clock tick interrupts have occurred
+@@ -99,7 +101,6 @@ uint64
+ sys_sigprocmask(void)
+ {
+   int sigmask;
+-
+   if(argint(0, &sigmask) < 0)
+     return -1;
+   return sigprocmask(sigmask);
+@@ -109,10 +110,11 @@ uint64
+ sys_sigaction(void)
+ {
+   int signum;
+-  uint64 act,oldact;
+-  if((argint(0, &signum) < 0) || (argaddr(1, &act) < 0) || (argaddr(2, &oldact) < 0))
++  uint64 new_act, old_act;
++
++  if( (argint(0, &signum) < 0) || (argaddr(1, &new_act) < 0) ||(argaddr(2, &old_act) < 0 ))
+     return -1;
+-  return sigaction(signum, act, oldact);
++  return sigaction(signum, new_act, old_act);
+ }
+ 
+ uint64
+diff --git a/kernel/trap.c b/kernel/trap.c
+index 9694d2e..c44f07d 100644
+--- a/kernel/trap.c
++++ b/kernel/trap.c
+@@ -5,7 +5,6 @@
+ #include "spinlock.h"
+ #include "proc.h"
+ #include "defs.h"
+-#include "sigaction.h"
+ 
+ struct spinlock tickslock;
+ uint ticks;
+@@ -91,8 +90,6 @@ void
+ usertrapret(void)
+ {
+   struct proc *p = myproc();
+-  
+-  
+ 
+   // we're about to switch the destination of traps from
+   // kerneltrap() to usertrap(), so turn off interrupts until
+@@ -102,7 +99,6 @@ usertrapret(void)
+   // send syscalls, interrupts, and exceptions to trampoline.S
+   w_stvec(TRAMPOLINE + (uservec - trampoline));
+ 
+-
+   // set up trapframe values that uservec will need when
+   // the process next re-enters the kernel.
+   p->trapframe->kernel_satp = r_satp();         // kernel page table
+@@ -112,22 +108,20 @@ usertrapret(void)
+ 
+   // set up the registers that trampoline.S's sret will use
+   // to get to user space.
+-
+   
+-
+   // set S Previous Privilege mode to User.
+   unsigned long x = r_sstatus();
+   x &= ~SSTATUS_SPP; // clear SPP to 0 for user mode
+   x |= SSTATUS_SPIE; // enable interrupts in user mode
+   w_sstatus(x);
+ 
+-
+   // set S Exception Program Counter to the saved user pc.
+   w_sepc(p->trapframe->epc);
+ 
+-  //our addition:
++  //--------------our additions--------------
+   handle_signals(p);
+-
++  //-----------------------------------------
++  
+   // tell trampoline.S the user page table to switch to.
+   uint64 satp = MAKE_SATP(p->pagetable);
+ 
+@@ -228,90 +222,60 @@ devintr()
+   }
+ }
+ 
+-//our additions:
+-
+-void handle_signals(struct proc *p)
++void handle_signals(struct proc* p)
+ {
+-  for (int signum = 0; signum < 32; signum++)
++  for (int signum=0 ; signum<NUM_OF_SIGNALS ; signum++)
+   {
+     if ((p->pending_signals & (1 << signum)) != 0)
+     {
+-      printf("pending signals:%d\n",p->pending_signals);
+-      p->pending_signals = p->pending_signals ^ (1 << signum);
+-      printf("pid:%d , handling signal:%d\n",p->pid,signum);
+-      switch (signum)
++      p->pending_signals = p->pending_signals ^ (1<<signum);
++      switch(signum)
+       {
+-      case SIGKILL:
+-        kill_handler(p);
+-        break;
+-      case SIGSTOP:
+-        stop_handler(p);
+-        break;
+-      case SIGCONT:
+-        break;
+-      default:
+-        if (p->signal_handlers[signum] == SIG_DFL)
+-        {
++        case SIGKILL:
+           kill_handler(p);
+-        }
+-        else
+-          handle_user_signal(p, signum);
+-        break;
++          break;
++        case SIGSTOP:
++          stop_handler(p);
++          break;
++        case SIGCONT:
++          break;
++        default:
++          break;
+       }
+     }
+   }
+ }
+ 
+-void handle_user_signal(struct proc *p, int signum)
+-{
+-  printf("handle user signal\n");
+-  copy_tf(p->trapframe,p->trapframe_backup);
+-  void* func =  p->signal_handlers[signum];
+-  p->trapframe->epc = (uint64) func;
+-  uint func_size = end_of_add_sigret - add_sigret ;
+-  p->trapframe->sp = p->trapframe->sp - func_size;
+-  p->trapframe->ra = p->trapframe->sp;
+-  memmove((void*)p->trapframe->sp,(void*)add_sigret,func_size);
+-  printf("out");
+-  //copyout(p->pagetable,p->trapframe->sp,(char*) add_sigret,20);
+-  w_sepc(p->trapframe->epc);
+-  return;
+-}
+-
+-
+ void kill_handler(struct proc *p)
+ {
+-  printf("in kill handler");
++  acquire(&p->lock);
+   p->killed = 1;
+   if(p->state == SLEEPING)
+-  {
+     p->state = RUNNABLE;
+-  }
++  release(&p->lock);
+ }
+ 
+-void stop_handler(struct proc* p)
++void stop_handler(struct proc *p)
+ {
+-  printf("in stop signal handler\n");
+-  p->freezed =1;
+-  while (p->freezed != 0)
++  printf("in stop handler\n");
++  acquire(&p->lock);
++  p->freezed = 1;
++  while (p->freezed == 1)
+   {
+-    if((p->pending_signals & 1 << SIGCONT) != 0)
++    if ((p->pending_signals & (1<<SIGCONT)) != 0)
++    {
+       p->freezed = 0;
+-    else 
++    }
++    else
++    {
++      printf("yielding\n");
++      release(&p->lock);
+       yield();
++    }
+   }
+-}
++  printf("exited stop handler\n");
++  release(&p->lock);
+ 
+-void add_sigret()
+-{
+-  asm("li a7, 24\n");
+-  asm("ecall\n");
+-  asm("ret\n");
+ }
+-void end_of_add_sigret(){}
+ 
+ 
+-void copy_tf(struct trapframe* src, struct trapframe* dst)
+-{
+-  memmove(dst,src,sizeof(struct trapframe));
+-}
+diff --git a/user/grind.c b/user/grind.c
+index c1b82e5..085583c 100644
+--- a/user/grind.c
++++ b/user/grind.c
+@@ -325,7 +325,7 @@ iter()
+   wait(&st1);
+   if(st1 != 0){
+     kill(pid1,SIGKILL);
+-    kill(pid2, SIGKILL);
++    kill(pid2,SIGKILL);
+   }
+   int st2 = -1;
+   wait(&st2);
+diff --git a/user/kill.c b/user/kill.c
+index e9abbc8..f8765ed 100644
+--- a/user/kill.c
++++ b/user/kill.c
+@@ -7,12 +7,11 @@ main(int argc, char **argv)
+ {
+   int i;
+ 
+-  if(argc < 2){
++  if((argc < 2) || (argc %2 != 1)){
+     fprintf(2, "usage: kill pid...\n");
+     exit(1);
+   }
+-  int signal = atoi(argv[argc - 1]);
+-  for(i=1; i<argc; i++)
+-    kill(atoi(argv[i]),signal);
++  for(i=1; i<argc-1; i+=2)
++    kill(atoi(argv[i]),atoi(argv[i+1]));
+   exit(0);
+ }
+diff --git a/user/test.c b/user/test.c
+index 17439e2..ba98a44 100644
+--- a/user/test.c
++++ b/user/test.c
+@@ -1,56 +1,77 @@
+ #include "kernel/types.h"
+ #include "user/user.h"
+ #include "kernel/fcntl.h"
++#include "kernel/param.h"
+ #include "kernel/sigaction.h"
+-
+-void func(int a)
+-{
+-    printf("hello world");
+-}
+-void func2()
++void test_sigprocmask1()
+ {
+-    sleep(15);
+-    printf("hello world\n");
+-    return;
++    uint a = sigprocmask(6);
++    uint b = sigprocmask(7);
++    if ((a == 0) && (b == 6))
++    {
++        printf("test_sigprocmask1:OK\n");
++    }
++    else{
++        printf("test_sigprocmask1:FAIL\n");
++        printf("a:%d , b:%d\n" , a,b);
++    }
+ }
+ 
+-void func3()
++void test_sigprocmask2()
+ {
+-    printf("hello from func 3\n");
+-    return;
++    uint a = sigaction(SIGKILL,0,0);
++    uint b = sigaction(SIGSTOP,0,0);
++    if ((a == -1) && (b == -1))
++    {
++        printf("test_sigprocmask2:OK\n");
++    }
++    else{
++        printf("test_sigprocmask2:FAIL\n");
++        printf("a:%d , b:%d\n" , a,b);
++    }
+ }
+ 
+-
+-int main(int argc, char** argv)
++void test_sigkill()
+ {
++    //int pid = fork();
+ 
++}
++void test_sigaction()
++{
++    struct sigaction a;
++    struct sigaction b;
++    a.sa_handler = (void*) 1234;
++    a.sigmask = 789;
++    sigaction(6,&a,0);
++    sigaction(6,0,&b);
++    if(b.sa_handler == (void*) 1234 && b.sigmask == 789)
++    {
++      printf("test_sigaction:OK\n");
++    }
++    else{
++        printf("test_sigaction:FAIL\n");
++    }
++}
+ 
+-    struct sigaction act;
+-    act.sa_handler = func2;
+ 
+-    //struct sigaction act2;
+-    //act2.sa_handler = func3;
+-    sigaction(3, &act , 0);
+-    //sigaction(8, &act2 , 0);
++int main()
++{
++    // test_sigprocmask1();
++    // test_sigprocmask2();
++    // test_sigaction();
+     int pid = fork();
+     if (pid == 0)
+     {
+-        sleep(30);
+-        printf("in child\n");
+-        while (1)
++        while(1)
+         {
+             sleep(20);
+-            printf("child");
++            printf("child\n");
+         }
+     }
+-    else
+-    {
+-        sleep(1);
+-        printf("child pid:%d\n",pid);
+-        kill(pid , 3);
+-        //kill(pid , 8);
+-        printf("sent both kills\n");
++    else{
++        printf("child:%d\n",pid);
+     }
++
+     exit(0);
+     return 0;
+-}  
+\ No newline at end of file
++}
+\ No newline at end of file
+diff --git a/user/user.h b/user/user.h
+index 8f79d31..e4bf7e7 100644
+--- a/user/user.h
++++ b/user/user.h
+@@ -10,7 +10,7 @@ int pipe(int*);
+ int write(int, const void*, int);
+ int read(int, void*, int);
+ int close(int);
+-int kill(int, int);
++int kill(int,int);
+ int exec(char*, char**);
+ int open(const char*, int);
+ int mknod(const char*, short, short);
+@@ -24,12 +24,11 @@ int getpid(void);
+ char* sbrk(int);
+ int sleep(int);
+ int uptime(void);
+-
+-//our addiotions:
+ uint sigprocmask(uint);
+ int sigaction(int, struct sigaction*, struct sigaction*);
+ void sigret(void);
+ 
++
+ // ulib.c
+ int stat(const char*, struct stat*);
+ char* strcpy(char*, const char*);
+diff --git a/user/usys.pl b/user/usys.pl
+index 4509524..836c7fe 100755
+--- a/user/usys.pl
++++ b/user/usys.pl
+@@ -38,4 +38,4 @@ entry("sleep");
+ entry("uptime");
+ entry("sigprocmask");
+ entry("sigaction");
+-entry("sigret");
++entry("sigret");
+\ No newline at end of file
diff --git a/kernel/defs.h b/kernel/defs.h
index 41098f4..4512223 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -8,6 +8,9 @@ struct spinlock;
 struct sleeplock;
 struct stat;
 struct superblock;
+struct trapframe;
+struct thread; 
+struct semaphore;
 
 // bio.c
 void            binit(void);
@@ -53,6 +56,10 @@ int             readi(struct inode*, int, uint64, uint, uint);
 void            stati(struct inode*, struct stat*);
 int             writei(struct inode*, int, uint64, uint, uint);
 void            itrunc(struct inode*);
+int             bsem_alloc(void);
+void            bsem_free(int fd);
+void            bsem_down(int fd);
+void            bsem_up(int fd);
 
 // ramdisk.c
 void            ramdiskinit(void);
@@ -89,10 +96,11 @@ int             growproc(int);
 void            proc_mapstacks(pagetable_t);
 pagetable_t     proc_pagetable(struct proc *);
 void            proc_freepagetable(pagetable_t, uint64);
-int             kill(int);
+int             kill(int,int);
 struct cpu*     mycpu(void);
 struct cpu*     getmycpu(void);
 struct proc*    myproc();
+struct thread*  mythread();
 void            procinit(void);
 void            scheduler(void) __attribute__((noreturn));
 void            sched(void);
@@ -105,7 +113,19 @@ void            yield(void);
 int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
 int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
 void            procdump(void);
-
+uint            sigprocmask(uint);
+int             sigaction(int, uint64, uint64);
+void            sigret(void);
+int             alloctid();
+void            exit_thread(int);
+int             kthread_create(uint64, uint64);
+int             kthread_id();
+void             kthread_exit(int);
+int             kthread_join(int, uint64);
+void            kthread_create_ret(void);
+void            print_ptable(void);
+void            semaphoresinit(void);
+int garbage(uint64);
 // swtch.S
 void            swtch(struct context*, struct context*);
 
@@ -146,6 +166,15 @@ void            trapinit(void);
 void            trapinithart(void);
 extern struct spinlock tickslock;
 void            usertrapret(void);
+void            handle_signals();
+void            kill_handler(int);
+void            stop_handler(int);
+void            call_sigret(void);
+void            end_call_sigret(void);
+void            user_handler(int);
+void            copy_tf(struct trapframe*,  struct trapframe*);
+
+
 
 // uart.c
 void            uartinit(void);
@@ -185,3 +214,8 @@ void            virtio_disk_intr(void);
 
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+
+
+
+
+
diff --git a/kernel/exec.c b/kernel/exec.c
index 0e8762f..d7eb345 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -97,10 +97,21 @@ exec(char *path, char **argv)
   if(copyout(pagetable, sp, (char *)ustack, (argc+1)*sizeof(uint64)) < 0)
     goto bad;
 
+  //---------------------our additions--------------
+  for (int i=0; i<NUM_OF_SIGNALS ; i++)
+  {
+    if ((p->signal_handlers[i] != SIG_DFL) && (p->signal_handlers[i] != (void*) SIG_IGN))
+    {
+      p->signal_handlers[i] = SIG_DFL;
+      p->signal_masks[i] = 0;
+    }
+  }
+  //------------------------------------------------
+
   // arguments to user main(argc, argv)
   // argc is returned via the system call return
   // value, which goes in a0.
-  p->trapframe->a1 = sp;
+  p->init_thread->trapframe->a1 = sp;
 
   // Save program name for debugging.
   for(last=s=path; *s; s++)
@@ -112,8 +123,8 @@ exec(char *path, char **argv)
   oldpagetable = p->pagetable;
   p->pagetable = pagetable;
   p->sz = sz;
-  p->trapframe->epc = elf.entry;  // initial program counter = main
-  p->trapframe->sp = sp; // initial stack pointer
+  p->init_thread->trapframe->epc = elf.entry;  // initial program counter = main
+  p->init_thread->trapframe->sp = sp; // initial stack pointer
   proc_freepagetable(oldpagetable, oldsz);
 
   return argc; // this ends up in a0, the first argument to main(argc, argv)
diff --git a/kernel/main.c b/kernel/main.c
index 5d7ad49..2c77046 100644
--- a/kernel/main.c
+++ b/kernel/main.c
@@ -29,6 +29,7 @@ main()
     fileinit();      // file table
     virtio_disk_init(); // emulated hard disk
     userinit();      // first user process
+    semaphoresinit();
     __sync_synchronize();
     started = 1;
   } else {
diff --git a/kernel/memlayout.h b/kernel/memlayout.h
index 776f98c..cc159c5 100644
--- a/kernel/memlayout.h
+++ b/kernel/memlayout.h
@@ -54,6 +54,8 @@
 // map kernel stacks beneath the trampoline,
 // each surrounded by invalid guard pages.
 #define KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE)
+#define KSTACK2(p,t) (TRAMPOLINE - (((p)+1)*NTHREAD*(t))* 2*PGSIZE)
+
 
 // User memory layout.
 // Address zero first:
diff --git a/kernel/param.h b/kernel/param.h
index b5fdcb2..2bb0c67 100644
--- a/kernel/param.h
+++ b/kernel/param.h
@@ -11,3 +11,14 @@
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
 #define FSSIZE       1000  // size of file system in blocks
 #define MAXPATH      128   // maximum file path name
+#define SIG_DFL       0
+#define SIG_IGN       1
+#define SIGKILL       9
+#define SIGSTOP       17
+#define SIGCONT       19
+#define NUM_OF_SIGNALS 32
+
+#define NTHREAD       8
+#define QUANTOM       5
+#define STACK_SIZE    4000  
+#define MAX_BSEM      128
\ No newline at end of file
diff --git a/kernel/proc.c b/kernel/proc.c
index 22e7ce4..2b1ccc7 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -5,16 +5,21 @@
 #include "spinlock.h"
 #include "proc.h"
 #include "defs.h"
+#include "user/sigaction.h"
+#include "semaphore.h"
 
 struct cpu cpus[NCPU];
 
 struct proc proc[NPROC];
 
+
+struct semaphore semaphores[MAX_BSEM];
 struct proc *initproc;
 
 int nextpid = 1;
 struct spinlock pid_lock;
 
+
 extern void forkret(void);
 static void freeproc(struct proc *p);
 
@@ -26,19 +31,165 @@ extern char trampoline[]; // trampoline.S
 // must be acquired before any p->lock.
 struct spinlock wait_lock;
 
+
+//----------------------------threads------------------------------------
+int nexttid = 1;
+struct spinlock tid_lock;
+
+// free a proc structure and the data hanging from it,
+// including user pages.
+// p->lock must be held.
+static void
+freethread(struct thread *t)
+{
+  if(t->tf_backup)
+    kfree((void*)t->tf_backup);
+  t->tid = 0;
+  t->parent = 0;
+  t->chan = 0;
+  t->killed = 0;
+  t->xstate = 0;
+  t->state = UNUSED;
+}
+
+int
+alloctid() {
+  int tid;
+  
+  acquire(&tid_lock);
+  tid = nexttid;
+  nexttid = nexttid + 1;
+  release(&tid_lock);
+
+  return tid;
+}
+
+
+// Look in the process table for an UNUSED proc.
+// If found, initialize state required to run in the kernel,
+// and return with p->lock held.
+// If there are no free procs, or a memory allocation fails, return 0.
+static struct thread*
+allocthread(struct proc* p)
+{
+  struct thread *t;
+  int index = 0;
+  for(t = p->threads; t < &p->threads[NTHREAD]; t++) 
+  {
+    acquire(&t->lock);
+    if(t->state == UNUSED) 
+    {
+      goto found;
+    } 
+    if(t->state == ZOMBIE)
+    {
+      freethread(t);
+    }
+    else 
+    {
+      release(&t->lock);
+    }
+    index++;
+  }
+  return 0;
+
+found:
+  t->tid = alloctid();
+  t->state = USED;
+  t->parent = p;
+
+  t->trapframe = &(p->trapframes[index]);
+  if((t->tf_backup = (struct trapframe *)kalloc()) == 0){
+    freethread(t);
+    release(&p->lock);
+    return 0;
+  }
+
+  // Set up new context to start executing at forkret,
+  // which returns to user space.
+  memset(&t->context, 0, sizeof(t->context));
+  t->context.sp = t->kstack + PGSIZE;
+  t->context.ra = (uint64)forkret;
+
+  return t;
+}
+
+void
+exit_thread(int status)
+{
+
+  struct thread *t = mythread();
+  struct proc* p = t->parent;
+
+  acquire(&p->lock);
+  p->alive_threads--;
+  int alive_threads = p->alive_threads;
+  release(&p->lock);
+
+  acquire(&wait_lock);
+  acquire(&t->lock);
+
+  t->xstate = status;
+  t->state = ZOMBIE;
+
+  if (alive_threads == 0)
+  {
+    // Close all open files.
+    for(int fd = 0; fd < NOFILE; fd++){
+      if(p->ofile[fd]){
+        struct file *f = p->ofile[fd];
+        fileclose(f);
+        p->ofile[fd] = 0;
+      }
+    }
+
+    begin_op();
+    iput(p->cwd);
+    end_op();
+    p->cwd = 0;
+
+    p->state = ZOMBIE_P;
+    p->killed = 1;
+  }
+  release(&wait_lock);
+
+  // Jump into the scheduler, never to return.
+  sched();
+  panic("zombie exit");
+}
+
+// Return the current struct proc *, or zero if none.
+struct thread*
+mythread(void) {
+  push_off();
+  struct cpu *c = mycpu();
+  struct thread *t = c->thread;
+  pop_off();
+  return t;
+}
+
+
+//-----------------------------------------end threads------------------------------------
+
 // Allocate a page for each process's kernel stack.
 // Map it high in memory, followed by an invalid
 // guard page.
 void
-proc_mapstacks(pagetable_t kpgtbl) {
+proc_mapstacks(pagetable_t kpgtbl) 
+{
   struct proc *p;
-  
-  for(p = proc; p < &proc[NPROC]; p++) {
-    char *pa = kalloc();
-    if(pa == 0)
-      panic("kalloc");
-    uint64 va = KSTACK((int) (p - proc));
-    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
+  struct thread* t;
+  for(p = proc; p < &proc[NPROC]; p++) 
+  {
+    for (t =p->threads; t<&p->threads[NTHREAD] ; t++)
+    {
+      char *pa = kalloc();
+      if(pa == 0)
+        panic("kalloc");
+      uint64 va = KSTACK((((int) (p - proc))*8) + ((int) (t-p->threads)));
+      // uint64 va = KSTACK2(((int) (p - proc)), ((int) (t-p->threads)));
+      kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
+    }
   }
 }
 
@@ -47,12 +198,19 @@ void
 procinit(void)
 {
   struct proc *p;
-  
+  struct thread* t;
+
   initlock(&pid_lock, "nextpid");
   initlock(&wait_lock, "wait_lock");
-  for(p = proc; p < &proc[NPROC]; p++) {
+  for(p = proc; p < &proc[NPROC]; p++) 
+  {
       initlock(&p->lock, "proc");
-      p->kstack = KSTACK((int) (p - proc));
+      for( t = p->threads ; t < &p->threads[NTHREAD] ; t++)
+      {
+        initlock(&t->lock, "thread");
+        t->kstack = KSTACK((int) (((p - proc)*8)+(((int) (t-p->threads)))));
+        // t->kstack = KSTACK2(((int) (p - proc)), ((int) (t-p->threads)));
+      }
   }
 }
 
@@ -80,7 +238,7 @@ struct proc*
 myproc(void) {
   push_off();
   struct cpu *c = mycpu();
-  struct proc *p = c->proc;
+  struct proc *p = c->thread->parent;
   pop_off();
   return p;
 }
@@ -97,6 +255,9 @@ allocpid() {
   return pid;
 }
 
+
+
+
 // Look in the process table for an UNUSED proc.
 // If found, initialize state required to run in the kernel,
 // and return with p->lock held.
@@ -105,10 +266,11 @@ static struct proc*
 allocproc(void)
 {
   struct proc *p;
+  struct thread* t;
 
   for(p = proc; p < &proc[NPROC]; p++) {
     acquire(&p->lock);
-    if(p->state == UNUSED) {
+    if(p->state == UNUSED_P) {
       goto found;
     } else {
       release(&p->lock);
@@ -118,16 +280,18 @@ allocproc(void)
 
 found:
   p->pid = allocpid();
-  p->state = USED;
-
-  // Allocate a trapframe page.
-  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
+  p->state = USED_P;
+  
+  
+  // Allocate a trapframes page.
+  if((p->trapframes = (struct trapframe *)kalloc()) == 0){
     freeproc(p);
     release(&p->lock);
     return 0;
   }
 
   // An empty user page table.
+
   p->pagetable = proc_pagetable(p);
   if(p->pagetable == 0){
     freeproc(p);
@@ -135,24 +299,40 @@ found:
     return 0;
   }
 
-  // Set up new context to start executing at forkret,
-  // which returns to user space.
-  memset(&p->context, 0, sizeof(p->context));
-  p->context.ra = (uint64)forkret;
-  p->context.sp = p->kstack + PGSIZE;
+  //-----------------our additions----------------
+  p->pending_signals = 0;
+  p->proc_signal_mask = 0;
+  for (int i=0 ; i<NUM_OF_SIGNALS ; i++)
+  {
+    p->signal_handlers[i] = SIG_DFL;
+    p->signal_masks[i] = 0;
+  }
+  p->signal_handling = 0;
+  p->freezed = 0;
+  //----------------------------------------------
+
+
+  t = allocthread(p);
+  p->init_thread = t;
+  p->alive_threads = 1;
 
   return p;
 }
 
+
+
+
 // free a proc structure and the data hanging from it,
 // including user pages.
 // p->lock must be held.
 static void
 freeproc(struct proc *p)
 {
-  if(p->trapframe)
-    kfree((void*)p->trapframe);
-  p->trapframe = 0;
+  for (struct thread* t = p->threads ; t<&p->threads[NTHREAD] ; t++)
+    freethread(t);
+  if(p->trapframes)
+     kfree((void*)p->trapframes);
+  p->trapframes = 0;
   if(p->pagetable)
     proc_freepagetable(p->pagetable, p->sz);
   p->pagetable = 0;
@@ -160,10 +340,10 @@ freeproc(struct proc *p)
   p->pid = 0;
   p->parent = 0;
   p->name[0] = 0;
-  p->chan = 0;
+  // p->chan = 0;
   p->killed = 0;
   p->xstate = 0;
-  p->state = UNUSED;
+  p->state = UNUSED_P;
 }
 
 // Create a user page table for a given process,
@@ -190,7 +370,7 @@ proc_pagetable(struct proc *p)
 
   // map the trapframe just below TRAMPOLINE, for trampoline.S.
   if(mappages(pagetable, TRAPFRAME, PGSIZE,
-              (uint64)(p->trapframe), PTE_R | PTE_W) < 0){
+              (uint64)(p->trapframes), PTE_R | PTE_W) < 0){
     uvmunmap(pagetable, TRAMPOLINE, 1, 0);
     uvmfree(pagetable, 0);
     return 0;
@@ -225,6 +405,7 @@ uchar initcode[] = {
 void
 userinit(void)
 {
+  printf("in user init\n");
   struct proc *p;
 
   p = allocproc();
@@ -236,14 +417,16 @@ userinit(void)
   p->sz = PGSIZE;
 
   // prepare for the very first "return" from kernel to user.
-  p->trapframe->epc = 0;      // user program counter
-  p->trapframe->sp = PGSIZE;  // user stack pointer
+  p->init_thread->trapframe->epc = 0;      // user program counter
+  p->init_thread->trapframe->sp = PGSIZE;  // user stack pointer
 
   safestrcpy(p->name, "initcode", sizeof(p->name));
   p->cwd = namei("/");
 
-  p->state = RUNNABLE;
+  p->init_thread->state = RUNNABLE;
+  p->state = ALIVE;
 
+  release(&p->init_thread->lock);
   release(&p->lock);
 }
 
@@ -275,7 +458,6 @@ fork(void)
   int i, pid;
   struct proc *np;
   struct proc *p = myproc();
-
   // Allocate process.
   if((np = allocproc()) == 0){
     return -1;
@@ -289,11 +471,22 @@ fork(void)
   }
   np->sz = p->sz;
 
+  //-------------------our additions-----------------
+  np->pending_signals = 0;
+  np->proc_signal_mask = p->proc_signal_mask;
+  for (int i=0 ; i<NUM_OF_SIGNALS ; i++)
+  {
+    np->signal_handlers[i] = p->signal_handlers[i];
+    np->signal_masks[i] = p->signal_masks[i];
+  }
+  //-------------------------------------------------
+
+  struct thread *t = mythread();
   // copy saved user registers.
-  *(np->trapframe) = *(p->trapframe);
+  *(np->init_thread->trapframe) = *(t->trapframe);
 
   // Cause fork to return 0 in the child.
-  np->trapframe->a0 = 0;
+  np->init_thread->trapframe->a0 = 0;
 
   // increment reference counts on open file descriptors.
   for(i = 0; i < NOFILE; i++)
@@ -305,15 +498,15 @@ fork(void)
 
   pid = np->pid;
 
+  np->state = ALIVE;
   release(&np->lock);
 
-  acquire(&wait_lock);
+  //acquire(&wait_lock);
   np->parent = p;
-  release(&wait_lock);
+  //release(&wait_lock);
 
-  acquire(&np->lock);
-  np->state = RUNNABLE;
-  release(&np->lock);
+  np->init_thread->state = RUNNABLE;
+  release(&np->init_thread->lock);
 
   return pid;
 }
@@ -344,19 +537,6 @@ exit(int status)
   if(p == initproc)
     panic("init exiting");
 
-  // Close all open files.
-  for(int fd = 0; fd < NOFILE; fd++){
-    if(p->ofile[fd]){
-      struct file *f = p->ofile[fd];
-      fileclose(f);
-      p->ofile[fd] = 0;
-    }
-  }
-
-  begin_op();
-  iput(p->cwd);
-  end_op();
-  p->cwd = 0;
 
   acquire(&wait_lock);
 
@@ -369,15 +549,34 @@ exit(int status)
   acquire(&p->lock);
 
   p->xstate = status;
-  p->state = ZOMBIE;
+  // p->state = ZOMBIE_P;
+
+  release(&p->lock);
 
+  for(struct thread* t = p->threads; t < &p->threads[NTHREAD]; t++)
+  {
+    acquire(&t->lock);
+    if (t->state != UNUSED)
+    {
+      t->killed = 1;
+      if(t->state == SLEEPING)
+      {
+        t->state = RUNNABLE;
+      }
+      }
+    release(&t->lock);
+  } 
   release(&wait_lock);
+  exit_thread(status);
 
+  
   // Jump into the scheduler, never to return.
   sched();
   panic("zombie exit");
 }
 
+
+
 // Wait for a child process to exit and return its pid.
 // Return -1 if this process has no children.
 int
@@ -389,20 +588,24 @@ wait(uint64 addr)
 
   acquire(&wait_lock);
 
-  for(;;){
+  for(;;)
+  {
     // Scan through table looking for exited children.
     havekids = 0;
-    for(np = proc; np < &proc[NPROC]; np++){
-      if(np->parent == p){
+    for(np = proc; np < &proc[NPROC]; np++)
+    {
+      if(np->parent == p)
+      {
         // make sure the child isn't still in exit() or swtch().
         acquire(&np->lock);
 
         havekids = 1;
-        if(np->state == ZOMBIE){
+        if(np->state == ZOMBIE_P)
+        {
           // Found one.
           pid = np->pid;
-          if(addr != 0 && copyout(p->pagetable, addr, (char *)&np->xstate,
-                                  sizeof(np->xstate)) < 0) {
+          if(addr != 0 && copyout(p->pagetable, addr, (char *)&np->xstate,sizeof(np->xstate)) < 0) 
+          {
             release(&np->lock);
             release(&wait_lock);
             return -1;
@@ -417,13 +620,15 @@ wait(uint64 addr)
     }
 
     // No point waiting if we don't have any children.
-    if(!havekids || p->killed){
+    if(!havekids || p->killed)
+    {
       release(&wait_lock);
       return -1;
     }
     
     // Wait for a child to exit.
     sleep(p, &wait_lock);  //DOC: wait-sleep
+    
   }
 }
 
@@ -439,27 +644,36 @@ scheduler(void)
 {
   struct proc *p;
   struct cpu *c = mycpu();
-  
-  c->proc = 0;
-  for(;;){
+  c->thread = 0;
+  for(;;)
+  {
     // Avoid deadlock by ensuring that devices can interrupt.
     intr_on();
 
-    for(p = proc; p < &proc[NPROC]; p++) {
-      acquire(&p->lock);
-      if(p->state == RUNNABLE) {
-        // Switch to chosen process.  It is the process's job
+    for(p = proc; p < &proc[NPROC]; p++) 
+    {
+      if(p->state == ALIVE) 
+      {
+
+        // Switch to chosen thread.  It is the thread's job
         // to release its lock and then reacquire it
-        // before jumping back to us.
-        p->state = RUNNING;
-        c->proc = p;
-        swtch(&c->context, &p->context);
-
-        // Process is done running for now.
-        // It should have changed its p->state before coming back.
-        c->proc = 0;
+        // before jumping back to us.        
+        for(struct thread* t = p->threads ; t< &p->threads[NTHREAD] ; t++)
+        {
+
+          acquire(&t->lock);
+          if(t->state == RUNNABLE)
+          {
+            t->state = RUNNING;
+            c->thread = t;
+            swtch(&c->context, &t->context);
+            // Process is done running for now.
+            // It should have changed its p->state before coming back.
+            c->thread = 0;
+          }
+          release(&t->lock);
+        }     
       }
-      release(&p->lock);
     }
   }
 }
@@ -475,19 +689,23 @@ void
 sched(void)
 {
   int intena;
-  struct proc *p = myproc();
-
-  if(!holding(&p->lock))
-    panic("sched p->lock");
+  struct thread *t = mythread();
+  
+  if(!holding(&t->lock))
+    panic("sched t->lock");
   if(mycpu()->noff != 1)
+  {
+    printf("noff:%d\n",mycpu()->noff);
     panic("sched locks");
-  if(p->state == RUNNING)
+  }
+  if(t->state == RUNNING)
     panic("sched running");
   if(intr_get())
-    panic("sched interruptible");
+  panic("sched interruptible");
 
   intena = mycpu()->intena;
-  swtch(&p->context, &mycpu()->context);
+  swtch(&t->context, &mycpu()->context);
+
   mycpu()->intena = intena;
 }
 
@@ -495,11 +713,11 @@ sched(void)
 void
 yield(void)
 {
-  struct proc *p = myproc();
-  acquire(&p->lock);
-  p->state = RUNNABLE;
+  struct thread *t = mythread();
+  acquire(&t->lock);
+  t->state = RUNNABLE;
   sched();
-  release(&p->lock);
+  release(&t->lock);
 }
 
 // A fork child's very first scheduling by scheduler()
@@ -510,7 +728,7 @@ forkret(void)
   static int first = 1;
 
   // Still holding p->lock from scheduler.
-  release(&myproc()->lock);
+  release(&myproc()->init_thread->lock);
 
   if (first) {
     // File system initialization must be run in the context of a
@@ -523,12 +741,13 @@ forkret(void)
   usertrapret();
 }
 
+
 // Atomically release lock and sleep on chan.
 // Reacquires lock when awakened.
 void
 sleep(void *chan, struct spinlock *lk)
 {
-  struct proc *p = myproc();
+  struct thread *t = mythread();
   
   // Must acquire p->lock in order to
   // change p->state and then call sched.
@@ -537,20 +756,20 @@ sleep(void *chan, struct spinlock *lk)
   // (wakeup locks p->lock),
   // so it's okay to release lk.
 
-  acquire(&p->lock);  //DOC: sleeplock1
+  acquire(&t->lock);  //DOC: sleeplock1
   release(lk);
 
   // Go to sleep.
-  p->chan = chan;
-  p->state = SLEEPING;
+  t->chan = chan;
+  t->state = SLEEPING;
 
   sched();
 
   // Tidy up.
-  p->chan = 0;
+  t->chan = 0;
 
   // Reacquire original lock.
-  release(&p->lock);
+  release(&t->lock);
   acquire(lk);
 }
 
@@ -560,14 +779,21 @@ void
 wakeup(void *chan)
 {
   struct proc *p;
-
-  for(p = proc; p < &proc[NPROC]; p++) {
-    if(p != myproc()){
-      acquire(&p->lock);
-      if(p->state == SLEEPING && p->chan == chan) {
-        p->state = RUNNABLE;
+  struct thread* t;
+
+  for(p = proc; p < &proc[NPROC]; p++) 
+  {
+    for ( t = p->threads ; t<&p->threads[NTHREAD] ; t++)
+    {
+      if(t != mythread())
+      {
+        acquire(&t->lock);
+        if(t->state == SLEEPING && t->chan == chan) 
+        {
+          t->state = RUNNABLE;
+        }
+        release(&t->lock);
       }
-      release(&p->lock);
     }
   }
 }
@@ -576,18 +802,15 @@ wakeup(void *chan)
 // The victim won't exit until it tries to return
 // to user space (see usertrap() in trap.c).
 int
-kill(int pid)
+kill(int pid, int signum)
 {
   struct proc *p;
 
   for(p = proc; p < &proc[NPROC]; p++){
     acquire(&p->lock);
     if(p->pid == pid){
-      p->killed = 1;
-      if(p->state == SLEEPING){
-        // Wake process from sleep().
-        p->state = RUNNABLE;
-      }
+      uint new_mask = (1<<signum);
+      p->pending_signals = p->pending_signals | new_mask ; 
       release(&p->lock);
       return 0;
     }
@@ -633,7 +856,7 @@ void
 procdump(void)
 {
   static char *states[] = {
-  [UNUSED]    "unused",
+  [UNUSED_P]    "unused",
   [SLEEPING]  "sleep ",
   [RUNNABLE]  "runble",
   [RUNNING]   "run   ",
@@ -644,7 +867,7 @@ procdump(void)
 
   printf("\n");
   for(p = proc; p < &proc[NPROC]; p++){
-    if(p->state == UNUSED)
+    if(p->state == UNUSED_P)
       continue;
     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
       state = states[p->state];
@@ -654,3 +877,229 @@ procdump(void)
     printf("\n");
   }
 }
+
+
+//change the proc signal mask to @param:sigmask and return the old one
+uint sigprocmask(uint sigmask)
+{
+  struct proc *p = myproc();
+  uint temp = p->proc_signal_mask;
+  p->proc_signal_mask = sigmask;
+  return temp;
+}
+
+//edit new signal handler when handeling the @param:signum signal 
+int sigaction(int signum , uint64 act, uint64 old_act)
+{
+  struct proc *p = myproc();
+  struct sigaction kold_act;
+  struct sigaction kact;
+  if((signum < 0 ) || (signum >= NUM_OF_SIGNALS) || (signum == SIGKILL) || (signum == SIGSTOP))
+  {
+    return -1;
+  }
+  if(old_act != 0)
+  {
+    kold_act.sa_handler = p->signal_handlers[signum];
+    kold_act.sigmask = p->signal_masks[signum];
+    copyout(p->pagetable, old_act, (char*) &kold_act, sizeof(struct sigaction));
+  }
+  if(act != 0)
+  {
+    copyin(p->pagetable, (char*) &kact, act, sizeof(struct sigaction));
+    uint invalid_mask = (1<<SIGKILL) | (1<<SIGSTOP);
+    if ((kact.sigmask & invalid_mask) != 0)
+    {
+      return -1;
+    }
+    p->signal_handlers[signum] = kact.sa_handler;
+    p->signal_masks[signum] = kact.sigmask;
+  }
+  return 0;
+}
+
+void sigret(void)
+{
+  struct thread* t = mythread();
+  struct proc* p = myproc();
+  copy_tf(t->trapframe, t->tf_backup);
+  p->proc_signal_mask = p->signal_mask_backup;
+  p->signal_handling = 0; 
+}
+
+
+int kthread_create(uint64 func_addr ,uint64 stack ) 
+{
+  struct proc *p = myproc();
+  struct thread *nt = allocthread(p);
+
+  acquire(&p->lock);
+  p->alive_threads++;
+  release(&p->lock);
+
+  struct thread *t = mythread();
+  if(nt == 0)
+    return -1;
+
+  copy_tf(nt->trapframe, t->trapframe);
+  nt->trapframe->epc = func_addr;
+  nt->trapframe->sp = stack + STACK_SIZE - 16; //TODO:
+  nt->state = RUNNABLE;
+  nt->context.ra = (uint64) kthread_create_ret;
+
+  //nt->lock held from allocthread
+  release(&nt->lock);
+  return nt->tid;
+}
+
+int kthread_id () 
+{
+  return mythread()->tid;
+}
+
+void kthread_exit(int status) 
+{
+  struct proc* p =myproc();
+  if (p->alive_threads == 1)
+    exit(status);
+  exit_thread(status);
+}
+
+int kthread_join(int thread_id , uint64 status) 
+{
+  struct proc* p = myproc();
+
+  for(struct thread *t = p->threads; t < &p->threads[NTHREAD]; t++)
+  {
+    if(t->tid == thread_id)
+    {
+      while(1)
+      {
+
+        printf("");
+        if( t->state == ZOMBIE)
+          break;
+      }
+      copyout(p->pagetable,status,(char*)&t->xstate,sizeof(t->xstate));
+      return 0;
+
+    }
+  }
+  return -1;
+}
+
+int garbage(uint64 a)
+{
+  return a+15;
+}
+
+void
+kthread_create_ret(void)
+{
+  struct thread* t = mythread();
+  t->killed=0;
+  // still holding t->lock from scheduler
+  release(&t->lock);
+
+  usertrapret();
+}
+
+void  semaphoresinit(void)
+{
+  for(int i = 0; i < MAX_BSEM; i++)
+  {
+    semaphores[i].state = UNUSED_SEM;
+    semaphores[i].taken = 0;
+    initlock(&semaphores[i].lk, "sempaphore lock");
+  }
+}
+
+int 
+bsem_alloc(void)
+{
+
+  for(int i = 0; i < MAX_BSEM; i++)
+  {
+    if(semaphores[i].state == UNUSED_SEM)
+    {
+      semaphores[i].state = USED_SEM;
+      semaphores[i].taken = 0;
+      return i;
+    }
+  }
+  return -1;
+}
+
+void
+bsem_free(int fd)
+{
+
+  semaphores[fd].state = UNUSED_SEM;
+  semaphores[fd].taken = 0;
+}
+
+void
+bsem_down(int fd)
+{
+  struct semaphore* sem = &semaphores[fd];
+  acquire(&sem->lk);
+  while(__sync_lock_test_and_set(&sem->taken, 1) != 0)
+  {
+    sleep(sem->chan, &sem->lk);
+  }
+  release(&sem->lk);
+  __sync_synchronize();
+  return;
+}
+
+void
+bsem_up(int fd)
+{
+
+  struct semaphore* sem = &semaphores[fd];
+  acquire(&sem->lk);
+  __sync_lock_test_and_set(&sem->taken, 0);
+  wakeup(sem->chan);
+  release(&sem->lk);
+
+}
+
+
+
+
+
+
+void print_ptable(void)
+{
+  for (int i=0 ; i<5 ; i++)
+  {
+    if (proc[i].pid == myproc()->pid)
+      printf("pid(me):%d\n",proc[i].pid);
+    else
+      printf("pid:%d\n",proc[i].pid);
+    printf("pstate:%s\n", proc[i].state == UNUSED_P ? "UNUSED" :
+                           proc[i].state == USED_P ? "USED" :
+                           proc[i].state == ALIVE ? "ALIVE" :
+                           "ZOMBIE_P");
+    printf("xstate:%d\n",proc[i].xstate);
+    for (int j=0 ; j<NTHREAD ; j++)
+    {
+      if (proc[i].threads[j].tid == mythread()->tid)
+        printf("\ttid(me):%d\n",proc[i].threads[j].tid);
+      else
+        printf("\ttid:%d\n",proc[i].threads[j].tid);
+      printf("\ttstate:%s\n", proc[i].threads[j].state == UNUSED ? "UNUSED" :
+                             proc[i].threads[j].state == USED ? "USED" :
+                             proc[i].threads[j].state == SLEEPING ? "SLEEPING" :
+                             proc[i].threads[j].state == RUNNABLE ? "RUNNABLE" :
+                             proc[i].threads[j].state == RUNNING ? "RUNNING" : 
+                             "ZOMBIE");
+      printf("\tkilled:%d\n",proc[i].threads[j].killed);
+    }
+  }
+}
+
+
+
+
+  
\ No newline at end of file
diff --git a/kernel/proc.h b/kernel/proc.h
index 8e90008..412128d 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -20,7 +20,7 @@ struct context {
 
 // Per-CPU state.
 struct cpu {
-  struct proc *proc;          // The process running on this cpu, or null.
+  struct thread *thread;       // The thread running on this cpu, or null.
   struct context context;     // swtch() here to enter scheduler().
   int noff;                   // Depth of push_off() nesting.
   int intena;                 // Were interrupts enabled before push_off()?
@@ -80,7 +80,33 @@ struct trapframe {
   /* 280 */ uint64 t6;
 };
 
-enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
+enum procstate { UNUSED_P, USED_P, ALIVE , ZOMBIE_P};
+
+
+
+//---------------------threads--------------------------
+enum threadstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
+
+struct thread
+{
+  struct spinlock lock;
+  // p->lock must be held when using these:
+  enum threadstate state;      // thread state
+  void *chan;                  // If non-zero, sleeping on chan
+  int killed;                  // If non-zero, have been killed
+  int xstate;                  // Exit status to be returned to parent's wait
+  int tid;                     // thread ID
+
+  // proc_tree_lock must be held when using this:
+  struct proc *parent;         // Parent process
+
+  // these are private to the process, so p->lock need not be held.
+  uint64 kstack;               // Virtual address of kernel stack
+  struct trapframe *trapframe; // data page for trampoline.S
+  struct trapframe *tf_backup;
+  struct context context;      // swtch() here to run process
+
+};
 
 // Per-process state
 struct proc {
@@ -88,21 +114,34 @@ struct proc {
 
   // p->lock must be held when using these:
   enum procstate state;        // Process state
-  void *chan;                  // If non-zero, sleeping on chan
   int killed;                  // If non-zero, have been killed
   int xstate;                  // Exit status to be returned to parent's wait
   int pid;                     // Process ID
-
+  int alive_threads;
+  
   // proc_tree_lock must be held when using this:
   struct proc *parent;         // Parent process
 
   // these are private to the process, so p->lock need not be held.
-  uint64 kstack;               // Virtual address of kernel stack
   uint64 sz;                   // Size of process memory (bytes)
   pagetable_t pagetable;       // User page table
-  struct trapframe *trapframe; // data page for trampoline.S
-  struct context context;      // swtch() here to run process
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  struct thread threads[NTHREAD];
+
+  //---------------------our additions------------------
+  uint pending_signals;
+  uint proc_signal_mask;
+  void *signal_handlers[NUM_OF_SIGNALS];
+  uint signal_masks[NUM_OF_SIGNALS];
+  int freezed;
+  uint signal_mask_backup;
+  uint signal_handling;
+  struct thread * init_thread;
+  struct trapframe *trapframes; // data page for trampoline.S
+
 };
+
+
+
diff --git a/kernel/semaphore.h b/kernel/semaphore.h
new file mode 100644
index 0000000..110a865
--- /dev/null
+++ b/kernel/semaphore.h
@@ -0,0 +1,11 @@
+enum semaphore_state{
+    UNUSED_SEM,
+    USED_SEM
+};
+
+struct semaphore {
+    enum semaphore_state state;
+    void *chan;                  // If non-zero, sleeping on chan
+    int taken;
+    struct spinlock lk;
+};
diff --git a/kernel/spinlock.c b/kernel/spinlock.c
index 9840302..e936689 100644
--- a/kernel/spinlock.c
+++ b/kernel/spinlock.c
@@ -21,6 +21,7 @@ initlock(struct spinlock *lk, char *name)
 void
 acquire(struct spinlock *lk)
 {
+  
   push_off(); // disable interrupts to avoid deadlock.
   if(holding(lk))
     panic("acquire");
@@ -46,6 +47,7 @@ acquire(struct spinlock *lk)
 void
 release(struct spinlock *lk)
 {
+  
   if(!holding(lk))
     panic("release");
 
diff --git a/kernel/syscall.c b/kernel/syscall.c
index c1b3670..4519022 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -34,20 +34,20 @@ fetchstr(uint64 addr, char *buf, int max)
 static uint64
 argraw(int n)
 {
-  struct proc *p = myproc();
+  struct thread *t = mythread();
   switch (n) {
   case 0:
-    return p->trapframe->a0;
+    return t->trapframe->a0;
   case 1:
-    return p->trapframe->a1;
+    return t->trapframe->a1;
   case 2:
-    return p->trapframe->a2;
+    return t->trapframe->a2;
   case 3:
-    return p->trapframe->a3;
+    return t->trapframe->a3;
   case 4:
-    return p->trapframe->a4;
+    return t->trapframe->a4;
   case 5:
-    return p->trapframe->a5;
+    return t->trapframe->a5;
   }
   panic("argraw");
   return -1;
@@ -104,43 +104,68 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_wait(void);
 extern uint64 sys_write(void);
 extern uint64 sys_uptime(void);
+extern uint64 sys_sigprocmask(void);
+extern uint64 sys_sigaction(void);
+extern uint64 sys_sigret(void);
+extern uint64 sys_kthread_create(void);
+extern uint64 sys_kthread_id(void);
+extern uint64 sys_kthread_exit(void);
+extern uint64 sys_kthread_join(void);
+extern uint64 sys_bsem_alloc(void);
+extern uint64 sys_bsem_free(void);
+extern uint64 sys_bsem_down(void);
+extern uint64 sys_bsem_up(void);
+
+extern uint64 sys_print_ptable(void);
 
 static uint64 (*syscalls[])(void) = {
-[SYS_fork]    sys_fork,
-[SYS_exit]    sys_exit,
-[SYS_wait]    sys_wait,
-[SYS_pipe]    sys_pipe,
-[SYS_read]    sys_read,
-[SYS_kill]    sys_kill,
-[SYS_exec]    sys_exec,
-[SYS_fstat]   sys_fstat,
-[SYS_chdir]   sys_chdir,
-[SYS_dup]     sys_dup,
-[SYS_getpid]  sys_getpid,
-[SYS_sbrk]    sys_sbrk,
-[SYS_sleep]   sys_sleep,
-[SYS_uptime]  sys_uptime,
-[SYS_open]    sys_open,
-[SYS_write]   sys_write,
-[SYS_mknod]   sys_mknod,
-[SYS_unlink]  sys_unlink,
-[SYS_link]    sys_link,
-[SYS_mkdir]   sys_mkdir,
-[SYS_close]   sys_close,
+[SYS_fork]                sys_fork,
+[SYS_exit]                sys_exit,
+[SYS_wait]                sys_wait,
+[SYS_pipe]                sys_pipe,
+[SYS_read]                sys_read,
+[SYS_kill]                sys_kill,
+[SYS_exec]                sys_exec,
+[SYS_fstat]               sys_fstat,
+[SYS_chdir]               sys_chdir,
+[SYS_dup]                 sys_dup,
+[SYS_getpid]              sys_getpid,
+[SYS_sbrk]                sys_sbrk,
+[SYS_sleep]               sys_sleep,
+[SYS_uptime]              sys_uptime,
+[SYS_open]                sys_open,
+[SYS_write]               sys_write,
+[SYS_mknod]               sys_mknod,
+[SYS_unlink]              sys_unlink,
+[SYS_link]                sys_link,
+[SYS_mkdir]               sys_mkdir,
+[SYS_close]               sys_close,
+[SYS_sigprocmask]         sys_sigprocmask,
+[SYS_sigaction]           sys_sigaction,
+[SYS_sigret]              sys_sigret,
+[SYS_kthread_create]      sys_kthread_create,
+[SYS_kthread_id]          sys_kthread_id,
+[SYS_kthread_exit]        sys_kthread_exit,
+[SYS_kthread_join]        sys_kthread_join,
+[SYS_bsem_alloc]          sys_bsem_alloc,
+[SYS_bsem_free]           sys_bsem_free,
+[SYS_bsem_down]           sys_bsem_down,
+[SYS_bsem_up]             sys_bsem_up,
+[SYS_print_ptable]        sys_print_ptable,
 };
 
 void
 syscall(void)
 {
   int num;
-  struct proc *p = myproc();
+  struct thread *t = mythread();
 
-  num = p->trapframe->a7;
+  num = t->trapframe->a7;
   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
-    p->trapframe->a0 = syscalls[num]();
+    t->trapframe->a0 = syscalls[num]();
   } else {
-    printf("%d %s: unknown sys call %d\n",
-            p->pid, p->name, num);
-    p->trapframe->a0 = -1;
+    printf("%d: unknown sys call %d\n",
+            t->tid, num);
+    t->trapframe->a0 = -1;
   }
 }
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..b9d1018 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -1,22 +1,35 @@
 // System call numbers
-#define SYS_fork    1
-#define SYS_exit    2
-#define SYS_wait    3
-#define SYS_pipe    4
-#define SYS_read    5
-#define SYS_kill    6
-#define SYS_exec    7
-#define SYS_fstat   8
-#define SYS_chdir   9
-#define SYS_dup    10
-#define SYS_getpid 11
-#define SYS_sbrk   12
-#define SYS_sleep  13
-#define SYS_uptime 14
-#define SYS_open   15
-#define SYS_write  16
-#define SYS_mknod  17
-#define SYS_unlink 18
-#define SYS_link   19
-#define SYS_mkdir  20
-#define SYS_close  21
+#define SYS_fork                1
+#define SYS_exit                2
+#define SYS_wait                3
+#define SYS_pipe                4
+#define SYS_read                5
+#define SYS_kill                6
+#define SYS_exec                7
+#define SYS_fstat               8
+#define SYS_chdir               9
+#define SYS_dup                 10
+#define SYS_getpid              11
+#define SYS_sbrk                12
+#define SYS_sleep               13
+#define SYS_uptime              14
+#define SYS_open                15
+#define SYS_write               16
+#define SYS_mknod               17
+#define SYS_unlink              18
+#define SYS_link                19
+#define SYS_mkdir               20
+#define SYS_close               21
+#define SYS_sigprocmask         22
+#define SYS_sigaction           23
+#define SYS_sigret              24
+#define SYS_kthread_create      25
+#define SYS_kthread_id          26
+#define SYS_kthread_exit        27
+#define SYS_kthread_join        28
+#define SYS_bsem_alloc          29
+#define SYS_bsem_free           30
+#define SYS_bsem_down           31
+#define SYS_bsem_up             32
+
+#define SYS_print_ptable        33
\ No newline at end of file
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index e8bcda9..ab8ed5d 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -77,10 +77,11 @@ uint64
 sys_kill(void)
 {
   int pid;
+  int signum; 
 
-  if(argint(0, &pid) < 0)
+  if((argint(0, &pid) < 0) || (argint(1, &signum) < 0))
     return -1;
-  return kill(pid);
+  return kill(pid,signum);
 }
 
 // return how many clock tick interrupts have occurred
@@ -95,3 +96,119 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+uint64
+sys_sigprocmask(void)
+{
+  int sigmask;
+  if(argint(0, &sigmask) < 0)
+    return -1;
+  return sigprocmask(sigmask);
+}
+
+uint64
+sys_sigaction(void)
+{
+  int signum;
+  uint64 new_act, old_act;
+
+  if( (argint(0, &signum) < 0) || (argaddr(1, &new_act) < 0) ||(argaddr(2, &old_act) < 0 ))
+    return -1;
+  return sigaction(signum, new_act, old_act);
+}
+
+uint64
+sys_sigret(void)
+{
+  sigret();
+  return 0;
+}
+uint64 sys_kthread_create(void)
+{
+  uint64 start_func,stack;
+
+  if(argaddr(0, &start_func) < 0|| argaddr(1, &stack) < 0)
+  {
+    return -1;
+  }
+  return kthread_create(start_func, stack);
+}
+
+uint64 sys_kthread_id(void)
+{
+  return kthread_id();
+}
+uint64 sys_kthread_exit(void)
+{
+  int status;
+
+  if(argint(0, &status) < 0)
+  {
+    return -1;
+  }
+  kthread_exit(status);
+  return 0;
+}
+uint64 sys_kthread_join(void)
+{
+  int thread_id;
+  uint64 status;
+  if(argint(0, &thread_id) < 0 || argaddr(1, &status) < 0)
+  {
+    return -1;
+  }
+  return kthread_join(thread_id, status);
+}
+
+uint64
+sys_print_ptable(void)
+{
+  print_ptable();
+  return 0;
+}
+
+
+uint64
+sys_bsem_alloc(void)
+{
+  return bsem_alloc();
+}
+
+uint64
+sys_bsem_free(void)
+{
+
+  int fd;
+  if(argint(0, &fd) < 0)
+  {
+    return -1;
+  }
+  bsem_free(fd);
+  return 0;
+}
+
+uint64
+sys_bsem_down(void)
+{
+  int fd;
+  if(argint(0, &fd) < 0)
+  {
+    return -1;
+  }
+  bsem_down(fd);
+  return 0;
+}
+
+uint64
+sys_bsem_up(void)
+{
+  int fd;
+  if(argint(0, &fd) < 0)
+  {
+    return -1;
+  }
+  bsem_up(fd);
+  return 0;
+}
+
+
diff --git a/kernel/thread.c b/kernel/thread.c
new file mode 100644
index 0000000..69f442e
--- /dev/null
+++ b/kernel/thread.c
@@ -0,0 +1,21 @@
+
+
+
+//TODO: decide
+// Allocate a page for each process's kernel stack.
+// Map it high in memory, followed by an invalid
+//  guard page.
+// void
+// proc_mapstacks(pagetable_t kpgtbl) {
+//   struct proc *p;
+  
+//   for(p = proc; p < &proc[NPROC]; p++) {
+//     char *pa = kalloc();
+//     if(pa == 0)
+//       panic("kalloc");
+//     uint64 va = KSTACK((int) (p - proc));
+//     kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
+//   }
+// }
+
+
diff --git a/kernel/trap.c b/kernel/trap.c
index a63249e..dea6d4b 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -45,20 +45,20 @@ usertrap(void)
   // since we're now in the kernel.
   w_stvec((uint64)kernelvec);
 
-  struct proc *p = myproc();
+  struct thread *t = mythread();
   
   // save user program counter.
-  p->trapframe->epc = r_sepc();
+  t->trapframe->epc = r_sepc();
   
   if(r_scause() == 8){
     // system call
 
-    if(p->killed)
-      exit(-1);
+    if(t->killed)
+      exit_thread(-1);
 
     // sepc points to the ecall instruction,
     // but we want to return to the next instruction.
-    p->trapframe->epc += 4;
+    t->trapframe->epc += 4;
 
     // an interrupt will change sstatus &c registers,
     // so don't enable until done with those registers.
@@ -68,17 +68,18 @@ usertrap(void)
   } else if((which_dev = devintr()) != 0){
     // ok
   } else {
-    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
+    printf("usertrap(): unexpected scause %p tid=%d\n", r_scause(), t->tid);
     printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
-    p->killed = 1;
+    t->killed = 1;
   }
 
-  if(p->killed)
-    exit(-1);
+  if(t->killed)
+    exit_thread(-1);
 
   // give up the CPU if this is a timer interrupt.
   if(which_dev == 2)
     yield();
+  
 
   usertrapret();
 }
@@ -90,21 +91,27 @@ void
 usertrapret(void)
 {
   struct proc *p = myproc();
+  struct thread* t =mythread();
+
 
   // we're about to switch the destination of traps from
   // kerneltrap() to usertrap(), so turn off interrupts until
   // we're back in user space, where usertrap() is correct.
   intr_off();
 
+
+  handle_signals();
+
+
   // send syscalls, interrupts, and exceptions to trampoline.S
   w_stvec(TRAMPOLINE + (uservec - trampoline));
 
   // set up trapframe values that uservec will need when
   // the process next re-enters the kernel.
-  p->trapframe->kernel_satp = r_satp();         // kernel page table
-  p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack
-  p->trapframe->kernel_trap = (uint64)usertrap;
-  p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()
+  t->trapframe->kernel_satp = r_satp();         // kernel page table
+  t->trapframe->kernel_sp = t->kstack + PGSIZE; // process's kernel stack
+  t->trapframe->kernel_trap = (uint64)usertrap;
+  t->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()
 
   // set up the registers that trampoline.S's sret will use
   // to get to user space.
@@ -116,16 +123,19 @@ usertrapret(void)
   w_sstatus(x);
 
   // set S Exception Program Counter to the saved user pc.
-  w_sepc(p->trapframe->epc);
+  w_sepc(t->trapframe->epc);
+
 
   // tell trampoline.S the user page table to switch to.
   uint64 satp = MAKE_SATP(p->pagetable);
 
+
+  int t_index = (int) (t - p->threads);
   // jump to trampoline.S at the top of memory, which 
   // switches to the user page table, restores user registers,
   // and switches to user mode with sret.
   uint64 fn = TRAMPOLINE + (userret - trampoline);
-  ((void (*)(uint64,uint64))fn)(TRAPFRAME, satp);
+  ((void (*)(uint64,uint64))fn)(TRAPFRAME+(t_index * sizeof(struct trapframe)), satp);
 }
 
 // interrupts and exceptions from kernel code go here via kernelvec,
@@ -150,9 +160,10 @@ kerneltrap()
   }
 
   // give up the CPU if this is a timer interrupt.
-  if(which_dev == 2 && myproc() != 0 && myproc()->state == RUNNING)
+  if(which_dev == 2 && mythread() != 0 && mythread()->state == RUNNING)
     yield();
 
+
   // the yield() may have caused some traps to occur,
   // so restore trap registers for use by kernelvec.S's sepc instruction.
   w_sepc(sepc);
@@ -218,3 +229,106 @@ devintr()
   }
 }
 
+void handle_signals()
+{
+  struct proc* p = myproc();
+  for (int signum=0 ; signum<NUM_OF_SIGNALS ; signum++)
+  {
+    if ( (p->proc_signal_mask & (1<<signum)) == 0)
+    {
+      if ((p->pending_signals & (1 << signum)) != 0)
+      {
+        p->pending_signals = p->pending_signals ^ (1<<signum);
+        switch(signum)
+        {
+          case SIGKILL:
+            kill_handler(signum);
+            break;
+          case SIGSTOP:
+            stop_handler(signum);
+            break;
+          case SIGCONT:
+            break;
+          case SIG_IGN:
+            break;
+          default:
+            user_handler(signum);
+            break;
+        }
+      }
+    }
+  }
+}
+
+void user_handler(int signum)
+{
+  struct proc* p = myproc();
+  struct thread* t = mythread();
+  if (p->signal_handling == 0)
+  {
+    copy_tf(t->tf_backup,t->trapframe);
+    uint func_size = end_call_sigret - call_sigret;
+    p->signal_mask_backup = p->proc_signal_mask;
+    p->proc_signal_mask = p->signal_masks[signum];
+    p->signal_handling = 1;
+    t->trapframe->sp -= sizeof(struct trapframe);
+    t->tf_backup->sp = t->trapframe->sp;
+    copyout(p->pagetable , t->tf_backup->sp , (char*) t->trapframe , sizeof(struct trapframe));
+    t->trapframe->epc = (uint64) p->signal_handlers[signum];
+    t->trapframe->sp -= func_size;
+    copyout(p->pagetable , t->trapframe->sp ,(char*) call_sigret , func_size);
+    t->trapframe->a0 = signum;
+    t->trapframe->ra = t->trapframe->sp;
+  }
+  else
+  {
+    p->pending_signals = p->pending_signals ^ (1<<signum);
+  }
+
+}
+
+void kill_handler(int signum)
+{
+  struct proc* p = myproc();
+  acquire(&p->lock);
+  for (struct thread* t=p->threads ; t<&p->threads[NTHREAD] ; t++)
+  {
+    acquire(&t->lock);
+    t->killed = 1;
+    if(t->state == SLEEPING)
+      t->state = RUNNABLE;
+    release(&t->lock);
+  }
+  release(&p->lock);
+}
+
+void stop_handler(int signum)
+{
+  struct proc* p = myproc();
+  p->freezed = 1;
+  while (p->freezed == 1)
+  {
+    if ((p->pending_signals & (1<<SIGCONT)) != 0)
+    {
+      p->freezed = 0;
+    }
+    else
+    {
+      yield();
+    }
+  }
+}
+
+void call_sigret()
+{
+  asm("li a7,24");
+  asm("ecall");
+  asm("ret");
+}
+
+void end_call_sigret(){}
+
+void copy_tf(struct trapframe* dst,  struct trapframe* src)
+{
+  memmove((void*)dst,(void*)src,sizeof(struct trapframe));
+}
\ No newline at end of file
diff --git a/user/Csemaphore.c b/user/Csemaphore.c
new file mode 100644
index 0000000..e4bb596
--- /dev/null
+++ b/user/Csemaphore.c
@@ -0,0 +1,52 @@
+#include "kernel/types.h"
+#include "user/user.h"
+#include "kernel/fcntl.h"
+#include "Csemaphore.h"
+
+int csem_alloc(struct counting_semaphore* sem, int initial_value)
+{
+    if (initial_value < 0)
+        return -1;
+    int s1 = bsem_alloc();
+    int s2 = bsem_alloc();
+
+    sem->s1 = s1;
+    sem->s2 = s2;
+    sem->value = initial_value;
+
+    if (initial_value == 0)
+        bsem_down(s2);
+
+    return 0;
+
+}
+
+void csem_free(struct counting_semaphore* sem)
+{
+    bsem_free(sem->s1);
+    bsem_free(sem->s2);
+}
+
+
+void csem_down(struct counting_semaphore* sem)
+{
+    bsem_down(sem->s2);
+    bsem_down(sem->s1);
+    sem->value = (sem->value)-1;
+    if(sem->value > 0)
+    {
+        bsem_up(sem->s2);
+    }
+    bsem_up(sem->s1);
+}
+
+void csem_up(struct counting_semaphore* sem)
+{
+    bsem_down(sem->s1);
+    sem->value++;
+    if(sem->value == 1)
+    {
+        bsem_up(sem->s2);
+    }
+    bsem_up(sem->s1);
+}
\ No newline at end of file
diff --git a/user/Csemaphore.h b/user/Csemaphore.h
new file mode 100644
index 0000000..92d974d
--- /dev/null
+++ b/user/Csemaphore.h
@@ -0,0 +1,13 @@
+
+struct counting_semaphore
+{
+    int s1;
+    int s2;
+    int value;
+};
+
+void csem_down(struct counting_semaphore* sem);
+void csem_up(struct counting_semaphore* sem);
+int csem_alloc(struct counting_semaphore* sem, int initial_value);
+void csem_free(struct counting_semaphore* sem);
+
diff --git a/user/grind.c b/user/grind.c
index 5cd89f4..085583c 100644
--- a/user/grind.c
+++ b/user/grind.c
@@ -142,12 +142,12 @@ go(int which_child)
         printf("grind: chdir failed\n");
         exit(1);
       }
-      kill(pid);
+      kill(pid,SIGKILL);
       wait(0);
     } else if(what == 18){
       int pid = fork();
       if(pid == 0){
-        kill(getpid());
+        kill(getpid(),SIGKILL);
         exit(0);
       } else if(pid < 0){
         printf("grind: fork failed\n");
@@ -324,8 +324,8 @@ iter()
   int st1 = -1;
   wait(&st1);
   if(st1 != 0){
-    kill(pid1);
-    kill(pid2);
+    kill(pid1,SIGKILL);
+    kill(pid2,SIGKILL);
   }
   int st2 = -1;
   wait(&st2);
diff --git a/user/kill.c b/user/kill.c
index 1b0253b..f8765ed 100644
--- a/user/kill.c
+++ b/user/kill.c
@@ -7,11 +7,11 @@ main(int argc, char **argv)
 {
   int i;
 
-  if(argc < 2){
+  if((argc < 2) || (argc %2 != 1)){
     fprintf(2, "usage: kill pid...\n");
     exit(1);
   }
-  for(i=1; i<argc; i++)
-    kill(atoi(argv[i]));
+  for(i=1; i<argc-1; i+=2)
+    kill(atoi(argv[i]),atoi(argv[i+1]));
   exit(0);
 }
diff --git a/user/print_ptable.c b/user/print_ptable.c
new file mode 100644
index 0000000..1bbc455
--- /dev/null
+++ b/user/print_ptable.c
@@ -0,0 +1,11 @@
+#include "kernel/types.h"
+#include "user/user.h"
+#include "kernel/fcntl.h"
+#include "kernel/param.h"
+
+int main()
+{
+
+    print_ptable();
+    exit(1);
+}
\ No newline at end of file
diff --git a/user/sem_test.c b/user/sem_test.c
new file mode 100644
index 0000000..b91bcd5
--- /dev/null
+++ b/user/sem_test.c
@@ -0,0 +1,46 @@
+#include "kernel/types.h"
+#include "user/user.h"
+#include "kernel/fcntl.h"
+#include "kernel/param.h"
+
+void func1(int s1)
+{
+    bsem_down(s1);
+    for(int i=0 ; i<20 ; i++)
+    {
+        printf("func1\n");
+    }
+    bsem_up(s1);
+}   
+
+void func2(int s1)
+{
+    bsem_down(s1);
+    for(int i=0 ; i<20 ; i++)
+    {
+        printf("------------func2------------- \n");
+    }
+    bsem_up(s1);
+}
+
+int main(){
+    int s1 = bsem_alloc();
+    if (s1 < 0 )
+    {
+        printf("bsem_alloc failed\n");
+    }
+
+    int pid = fork();
+
+    if(pid == 0)
+    {
+        //child
+        func1(s1);
+    }
+    else
+    {
+        //parent
+        func2(s1);
+    }
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/sh.c b/user/sh.c
index 83dd513..60dfd0d 100644
--- a/user/sh.c
+++ b/user/sh.c
@@ -157,6 +157,7 @@ main(void)
 
   // Read and run input commands.
   while(getcmd(buf, sizeof(buf)) >= 0){
+    
     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
       // Chdir must be called by the parent, not the child.
       buf[strlen(buf)-1] = 0;  // chop \n
diff --git a/user/sigaction.h b/user/sigaction.h
new file mode 100644
index 0000000..fef16e5
--- /dev/null
+++ b/user/sigaction.h
@@ -0,0 +1,6 @@
+#include "kernel/types.h"
+
+struct sigaction {
+    void (*sa_handler) (int);
+    uint sigmask;
+};
\ No newline at end of file
diff --git a/user/test.c b/user/test.c
new file mode 100644
index 0000000..dd3f4c0
--- /dev/null
+++ b/user/test.c
@@ -0,0 +1,35 @@
+#include "kernel/types.h"
+#include "user/user.h"
+#include "kernel/fcntl.h"
+#include "kernel/param.h"
+#include "sigaction.h"
+#include "Csemaphore.h"
+
+struct counting_semaphore* sem;
+
+void func1()
+{
+  for (int i=0 ;i<100; i++)
+  {
+    printf("thread1 func %d\n",i);
+  }
+  sleep(10);
+  kthread_exit(22);
+}
+
+
+
+
+int main()
+{
+    sem = malloc(sizeof(struct counting_semaphore));
+    csem_alloc(sem,2);
+    void* stack1 = malloc(STACK_SIZE);
+    int tid =  kthread_create(func1,stack1);
+    // printf("hello");
+    int status;
+    kthread_join(tid,&status);
+    printf("thread status:%d\n",status);
+    kthread_exit(1);
+    return 0;
+}
\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index b71ecda..b26200e 100644
--- a/user/user.h
+++ b/user/user.h
@@ -1,6 +1,6 @@
 struct stat;
 struct rtcdate;
-
+struct sigaction;
 // system calls
 int fork(void);
 int exit(int) __attribute__((noreturn));
@@ -9,7 +9,7 @@ int pipe(int*);
 int write(int, const void*, int);
 int read(int, void*, int);
 int close(int);
-int kill(int);
+int kill(int,int);
 int exec(char*, char**);
 int open(const char*, int);
 int mknod(const char*, short, short);
@@ -23,6 +23,19 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+uint sigprocmask(uint);
+int sigaction(int, struct sigaction*, struct sigaction*);
+void sigret(void);
+int kthread_create(void (*start_func) () , void *stack );
+int kthread_id(void);
+int kthread_exit(int);
+int kthread_join(int, int*);
+int bsem_alloc(void);
+void bsem_free(int);
+void bsem_down(int);
+void bsem_up(int);
+
+void print_ptable(void);
 
 // ulib.c
 int stat(const char*, struct stat*);
@@ -40,3 +53,7 @@ void free(void*);
 int atoi(const char*);
 int memcmp(const void *, const void *, uint);
 void *memcpy(void *, const void *, uint);
+
+
+// Csemaphore.c
+
diff --git a/user/usertests.c b/user/usertests.c
index ba4255b..c20533e 100644
--- a/user/usertests.c
+++ b/user/usertests.c
@@ -8,6 +8,12 @@
 #include "kernel/memlayout.h"
 #include "kernel/riscv.h"
 
+
+#include "kernel/spinlock.h"  // NEW INCLUDE FOR ASS2
+#include "Csemaphore.h"   // NEW INCLUDE FOR ASS 2
+#include "kernel/proc.h"         // NEW INCLUDE FOR ASS 2, has all the signal definitions and sigaction definition.  Alternatively, copy the relevant things into user.h and include only it, and then no need to include spinlock.h .
+#include "sigaction.h"
+
 //
 // Tests xv6 system calls.  usertests without arguments runs them all
 // and usertests <name> runs <name> test. The test runner creates for
@@ -17,10 +23,118 @@
 // prints "OK".
 //
 
+#define SIGKILL 9
 #define BUFSZ  ((MAXOPBLOCKS+2)*BSIZE)
 
 char buf[BUFSZ];
 
+
+int wait_sig = 0;
+
+void test_handler(int signum){
+    wait_sig = 1;
+    printf("Received sigtest\n");
+}
+
+void test_thread(){
+    // printf("Thread is now running\n");
+    // kthread_exit(0);
+}
+
+void signal_test(char *s){
+    int pid;
+    int testsig;
+    testsig=15;
+    printf("test_handler:%p",test_handler);
+    struct sigaction act = {test_handler, (uint)(1 << 29)};
+    struct sigaction old;
+
+    sigprocmask(0);
+    sigaction(testsig, &act, &old);
+    if((pid = fork()) == 0){
+        while(!wait_sig)
+            sleep(1);
+        exit(0);
+    }
+    kill(pid, testsig);
+    wait(&pid);
+    printf("Finished testing signals\n");
+}
+
+void thread_test(char *s){
+    int tid;
+    int status;
+    void* stack = malloc(STACK_SIZE);
+    tid = kthread_create(test_thread, stack);
+    kthread_join(tid,&status);
+
+    tid = kthread_id();
+    free(stack);
+    printf("Finished testing threads, main thread id: %d, %d\n", tid,status);
+}
+
+
+void bsem_test(char *s){
+    int pid;
+    int bid = bsem_alloc();
+    bsem_down(bid);
+    printf("1. Parent downing semaphore\n");
+    if((pid = fork()) == 0){
+        printf("2. Child downing semaphore\n");
+        bsem_down(bid);
+        printf("4. Child woke up\n");
+        exit(0);
+    }
+    sleep(5);
+    printf("3. Let the child wait on the semaphore...\n");
+    sleep(10);
+    bsem_up(bid);
+
+    bsem_free(bid);
+    wait(&pid);
+
+    printf("Finished bsem test, make sure that the order of the prints is alright. Meaning (1...2...3...4)\n");
+}
+
+
+void Csem_test(char *s){
+	struct counting_semaphore csem;
+    int retval;
+    int pid;
+    
+    
+    retval = csem_alloc(&csem,1);
+    if(retval==-1)
+    {
+		printf("failed csem alloc");
+		exit(-1);
+	}
+    csem_down(&csem);
+    printf("1. Parent downing semaphore\n");
+    if((pid = fork()) == 0){
+        printf("2. Child downing semaphore\n");
+        csem_down(&csem);
+        printf("4. Child woke up\n");
+        exit(0);
+    }
+    sleep(5);
+    printf("3. Let the child wait on the semaphore...\n");
+    sleep(10);
+    csem_up(&csem);
+
+    csem_free(&csem);
+    wait(&pid);
+
+    printf("Finished bsem test, make sure that the order of the prints is alright. Meaning (1...2...3...4)\n");
+}
+
+
+
+
+
+
+
+
 // what if you pass ridiculous pointers to system calls
 // that read user memory with copyin?
 void
@@ -799,7 +913,7 @@ killstatus(char *s)
       exit(0);
     }
     sleep(1);
-    kill(pid1);
+    kill(pid1, SIGKILL);
     wait(&xst);
     if(xst != -1) {
        printf("%s: status should be -1\n", s);
@@ -856,9 +970,9 @@ preempt(char *s)
   }
   close(pfds[0]);
   printf("kill... ");
-  kill(pid1);
-  kill(pid2);
-  kill(pid3);
+  kill(pid1, SIGKILL);
+  kill(pid2, SIGKILL);
+  kill(pid3, SIGKILL);
   printf("wait... ");
   wait(0);
   wait(0);
@@ -914,7 +1028,7 @@ reparent(char *s)
     } else {
       int pid2 = fork();
       if(pid2 < 0){
-        kill(master_pid);
+        kill(master_pid, SIGKILL);
         exit(1);
       }
       exit(0);
@@ -2263,7 +2377,7 @@ sbrkfail(char *s)
   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
     if(pids[i] == -1)
       continue;
-    kill(pids[i]);
+    kill(pids[i], SIGKILL);
     wait(0);
   }
   if(c == (char*)0xffffffffffffffffL){
@@ -2766,67 +2880,74 @@ main(int argc, char *argv[])
     void (*f)(char *);
     char *s;
   } tests[] = {
-    {manywrites, "manywrites"},
-    {execout, "execout"},
-    {copyin, "copyin"},
-    {copyout, "copyout"},
-    {copyinstr1, "copyinstr1"},
-    {copyinstr2, "copyinstr2"},
-    {copyinstr3, "copyinstr3"},
-    {rwsbrk, "rwsbrk" },
-    {truncate1, "truncate1"},
-    {truncate2, "truncate2"},
-    {truncate3, "truncate3"},
-    {reparent2, "reparent2"},
-    {pgbug, "pgbug" },
-    {sbrkbugs, "sbrkbugs" },
-    // {badwrite, "badwrite" },
-    {badarg, "badarg" },
-    {reparent, "reparent" },
-    {twochildren, "twochildren"},
-    {forkfork, "forkfork"},
-    {forkforkfork, "forkforkfork"},
-    {argptest, "argptest"},
-    {createdelete, "createdelete"},
-    {linkunlink, "linkunlink"},
-    {linktest, "linktest"},
-    {unlinkread, "unlinkread"},
-    {concreate, "concreate"},
-    {subdir, "subdir"},
-    {fourfiles, "fourfiles"},
-    {sharedfd, "sharedfd"},
-    {dirtest, "dirtest"},
-    {exectest, "exectest"},
-    {bigargtest, "bigargtest"},
-    {bigwrite, "bigwrite"},
-    {bsstest, "bsstest"},
-    {sbrkbasic, "sbrkbasic"},
-    {sbrkmuch, "sbrkmuch"},
-    {kernmem, "kernmem"},
-    {sbrkfail, "sbrkfail"},
-    {sbrkarg, "sbrkarg"},
-    {validatetest, "validatetest"},
-    {stacktest, "stacktest"},
-    {opentest, "opentest"},
-    {writetest, "writetest"},
-    {writebig, "writebig"},
-    {createtest, "createtest"},
-    {openiputtest, "openiput"},
-    {exitiputtest, "exitiput"},
-    {iputtest, "iput"},
-    {mem, "mem"},
-    {pipe1, "pipe1"},
-    {killstatus, "killstatus"},
-    {preempt, "preempt"},
-    {exitwait, "exitwait"},
-    {rmdot, "rmdot"},
-    {fourteen, "fourteen"},
-    {bigfile, "bigfile"},
-    {dirfile, "dirfile"},
-    {iref, "iref"},
-    {forktest, "forktest"},
-    {bigdir, "bigdir"}, // slow
-    { 0, 0},
+	  //ASS 2 Compilation tests:
+	  {signal_test,"signal_test"},
+	  {thread_test,"thread_test"},
+	  {bsem_test,"bsem_test"},
+	  {Csem_test,"Csem_test"},
+		  
+// // // xv6 included tests:  // comented out long tests
+// //     {manywrites, "manywrites"},  //800 ticks, too long
+// //     {execout, "execout"}, //1600 ticks, too long
+// //     {copyin, "copyin"},//5 ticks
+// //     {copyout, "copyout"},// 0 ticks
+// //     {copyinstr1, "copyinstr1"},// 0 ticks
+// //     {copyinstr2, "copyinstr2"},// 1 ticks
+// //     {copyinstr3, "copyinstr3"},// 0 ticks
+// //     {rwsbrk, "rwsbrk" },// 3 ticks
+// //     {truncate1, "truncate1"},// 4 ticks
+// //     {truncate2, "truncate2"},// 4 ticks
+// //     {truncate3, "truncate3"},// 0 ticks
+// //     {reparent2, "reparent2"},// 600 ticks, causes fails in 
+// //     {pgbug, "pgbug" },// 0 ticks
+// //     //  {sbrkbugs, "sbrkbugs" }, // 1 ticks failing
+// //     {badwrite, "badwrite" },
+// //     {badarg, "badarg" },// 200 ticks
+// //     //   {reparent, "reparent" }, // failing
+// //     {twochildren, "twochildren"},
+// //       {forkfork, "forkfork"},
+// //     //   {forkforkfork, "forkforkfork"}, //failing
+// //     {argptest, "argptest"},// 1 ticks
+// //     {createdelete, "createdelete"},// 200 ticks
+// //     {linkunlink, "linkunlink"},// 80 ticks
+// //     {linktest, "linktest"},// 9 ticks
+// //     {unlinkread, "unlinkread"},// 7 ticks
+// //     {concreate, "concreate"},// 430 ticks
+// //     {subdir, "subdir"},// 24 ticks
+// //     {fourfiles, "fourfiles"},// 26 ticks
+// //     {sharedfd, "sharedfd"},// 200 ticks
+// //     {dirtest, "dirtest"},// 4 ticks
+// //     {exectest, "exectest"},// 0 ticks
+// //     {bigargtest, "bigargtest"},//4 ticks
+// //     {bigwrite, "bigwrite"},// 170 ticks
+// //     {bsstest, "bsstest"},// 0 ticks
+// //     {sbrkbasic, "sbrkbasic"},// 90 ticks
+// //     {sbrkmuch, "sbrkmuch"},// 70 ticks
+//     //    {kernmem, "kernmem"},// 17 ticks failing
+//     //    {sbrkfail, "sbrkfail"},// 300 ticks failing
+//     // {sbrkarg, "sbrkarg"},// 4 ticks
+//     // {validatetest, "validatetest"},// 11 ticks
+//     //    //{stacktest, "stacktest"},// 0 ticks failing
+//     {opentest, "opentest"},// 1 ticks
+//     {writetest, "writetest"},// 50 ticks
+//     {writebig, "writebig"},// 130 ticks
+//     {createtest, "createtest"},// 200 ticks
+//     {openiputtest, "openiput"},// 5 ticks
+//     {exitiputtest, "exitiput"},// 5 ticks
+//     {iputtest, "iput"},// 4 ticks
+//     {mem, "mem"},// 200 ticks
+//     {pipe1, "pipe1"},// 1 ticks
+//     {killstatus, "killstatus"},//150 ticks
+//     //   {preempt, "preempt"},    // failing
+//     {exitwait, "exitwait"},// 18 ticks
+//     {rmdot, "rmdot"},//6 ticks
+//     {fourteen, "fourteen"},// 12 ticks
+//     {bigfile, "bigfile"},// 12 ticks
+//     {dirfile, "dirfile"},// 4 ticks
+//     {iref, "iref"},// 160 ticks
+//     {forktest, "forktest"}, // 14 ticks
+//     {bigdir, "bigdir"}, // slow // 3800 ticks
+       { 0, 0},
   };
 
   if(continuous){
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..7ebdc95 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,15 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("sigprocmask");
+entry("sigaction");
+entry("sigret");
+entry("kthread_create");
+entry("kthread_id");
+entry("kthread_exit");
+entry("kthread_join");
+entry("bsem_alloc");
+entry("bsem_free");
+entry("bsem_down");
+entry("bsem_up");
+entry("print_ptable");
\ No newline at end of file
